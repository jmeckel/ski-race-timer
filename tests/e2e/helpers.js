/**
 * E2E Test Helpers
 * Shared utilities for all E2E tests
 *
 * Note: The timer view now uses a radial dial UI by default
 * Key selectors for radial mode:
 * - Number input: .dial-number[data-num="X"] (generated by RadialDial component)
 * - Clear button: #radial-clear-btn
 * - Timestamp button: #radial-time-btn
 * - Bib display: #radial-bib-value
 * - Timing points: .radial-point-btn[data-point="S|F"]
 * - Run selector: #radial-run-selector .radial-run-btn[data-run="X"]
 * - Confirmation: #radial-confirmation-overlay.show
 */

/**
 * Setup page with onboarding bypassed and clean state.
 * @param {import('@playwright/test').Page} page
 * @param {string} lang - Language code: 'de' (default), 'en', or 'fr'
 */
export async function setupPage(page, lang = 'de') {
  await page.addInitScript((lang) => {
    localStorage.setItem('skiTimerHasCompletedOnboarding', 'true');
    localStorage.setItem(
      'skiTimerSettings',
      JSON.stringify({
        auto: true,
        haptic: true,
        sound: false,
        sync: false,
        syncPhotos: false,
        gps: false,
        simple: false,
        photoCapture: false,
      }),
    );
    localStorage.setItem('skiTimerLang', lang);
  }, lang);

  await page.goto('/');
  await page.waitForSelector('#radial-time-hm', { timeout: 5000 });
}

/** @deprecated Use setupPage(page, 'en') instead */
export async function setupPageEnglish(page) {
  return setupPage(page, 'en');
}

/** @deprecated Use setupPage(page, 'fr') instead */
export async function setupPageFrench(page) {
  return setupPage(page, 'fr');
}

/**
 * Setup page with sync enabled
 */
export async function setupPageWithSync(page, raceId = 'TEST-RACE') {
  await page.addInitScript((raceId) => {
    localStorage.setItem('skiTimerHasCompletedOnboarding', 'true');
    // Keys must match the store's DEFAULT_SETTINGS
    localStorage.setItem(
      'skiTimerSettings',
      JSON.stringify({
        auto: true,
        haptic: true,
        sound: false,
        sync: true, // Sync enabled
        syncPhotos: false,
        gps: false,
        simple: false, // Full mode for sync testing
        photoCapture: false,
      }),
    );
    localStorage.setItem('skiTimerLang', 'de');
    localStorage.setItem('skiTimerRaceId', raceId);
  }, raceId);

  await page.goto('/');
  await page.waitForSelector('#radial-time-hm', { timeout: 5000 });
}

/**
 * Clear all app data
 */
export async function clearAppData(page) {
  await page.evaluate(() => {
    localStorage.removeItem('skiTimerEntries');
    localStorage.removeItem('skiTimerSettings');
    localStorage.removeItem('skiTimerRaceId');
    localStorage.removeItem('skiTimerDeviceId');
    localStorage.removeItem('skiTimerAuthToken');
    localStorage.removeItem('skiTimerRecentRaces');
    // Keep onboarding bypassed
    localStorage.setItem('skiTimerHasCompletedOnboarding', 'true');
  });
}

/**
 * Click a toggle by clicking its label wrapper
 */
export async function clickToggle(page, toggleSelector) {
  await page.locator(`label:has(${toggleSelector})`).click();
}

/**
 * Check if toggle is on
 */
export async function isToggleOn(page, toggleSelector) {
  return await page.locator(toggleSelector).isChecked();
}

/**
 * Navigate to a specific view and wait for it to be visible
 */
export async function navigateTo(page, view) {
  // Map view name to panel ID
  const panelIds = {
    timer: '#timer-panel',
    results: '#results-panel',
    settings: '#settings-panel',
    gateJudge: '#gate-judge-panel',
  };

  // data-view values match view names directly: timer, results, settings
  await page.click(`[data-view="${view}"]`);

  // Wait for the target panel to become the active view
  const panelId = panelIds[view];
  if (panelId) {
    await page.waitForSelector(`${panelId}.active`, { timeout: 5000 });
  }
}

/**
 * Record a timestamp with optional bib number
 * Uses radial dial UI selectors
 */
export async function recordTimestamp(page, bib = null) {
  if (bib) {
    // Clear current bib via keyboard
    await page.keyboard.press('Delete');
    // Enter new bib via keyboard
    for (const digit of bib.toString()) {
      await page.keyboard.press(digit);
    }
  }
  await page.click('#radial-time-btn');
  // Wait for confirmation overlay
  await page.waitForSelector('#radial-confirmation-overlay.show', {
    timeout: 2000,
  });
}

/**
 * Wait for any toast notifications to disappear
 * Useful when toast intercepts pointer events on underlying buttons
 */
export async function waitForToastToHide(page) {
  await page
    .waitForFunction(
      () => {
        const toast = document.querySelector('.toast');
        return !toast || !toast.closest('#toast-container');
      },
      { timeout: 5000 },
    )
    .catch(() => {
      // Toast might not exist - continue
    });
  // Small buffer for animation
  await page.waitForTimeout(100);
}

/**
 * Wait for confirmation overlay to disappear
 * Increased timeout for slower CI environments (especially mobile-safari)
 * Uses radial confirmation overlay selector
 */
export async function waitForConfirmationToHide(page) {
  // First wait for it to appear (if not already visible)
  try {
    await page.waitForSelector('#radial-confirmation-overlay.show', {
      timeout: 2000,
    });
  } catch {
    // Overlay might have already hidden or never appeared - continue
  }
  // Then wait for it to hide
  await page.waitForSelector('#radial-confirmation-overlay.show', {
    state: 'hidden',
    timeout: 5000,
  });
}

/**
 * Enter bib number via radial dial
 * Uses dial numbers generated by RadialDial component
 */
export async function enterBib(page, bib) {
  // Clear current bib via keyboard (Delete key)
  await page.keyboard.press('Delete');
  // Enter bib digits via keyboard (0-9 keys bypass radial dial coordinate issues)
  for (const digit of bib.toString().padStart(3, '0')) {
    await page.keyboard.press(digit);
  }
}

/**
 * Wait for localStorage to have a specific key with data.
 * Replaces arbitrary waitForTimeout after actions that trigger debounced saves.
 * @param {import('@playwright/test').Page} page
 * @param {string} key - localStorage key to check
 * @param {number} timeout - Max wait time in ms (default 3000)
 */
export async function waitForStorageSave(page, key, timeout = 3000) {
  await page.waitForFunction((k) => localStorage.getItem(k) !== null, key, {
    timeout,
  });
}

/**
 * Wait for focus to be inside a specific element.
 * Replaces arbitrary waitForTimeout after modal open for deferred focus.
 * @param {import('@playwright/test').Page} page
 * @param {string} selector - CSS selector for the container element
 * @param {number} timeout - Max wait time in ms (default 3000)
 */
export async function waitForFocusInside(page, selector, timeout = 3000) {
  await page.waitForFunction(
    (sel) => {
      const container = document.querySelector(sel);
      return container?.contains(document.activeElement) ?? false;
    },
    selector,
    { timeout },
  );
}

/**
 * Dismiss all visible toast notifications by removing them from the DOM.
 * Useful when toasts intercept pointer events on underlying buttons.
 */
export async function dismissToasts(page) {
  await page.evaluate(() =>
    document.querySelectorAll('.toast').forEach((t) => t.remove()),
  );
}

/**
 * Add multiple test entries via keyboard input.
 * Each entry uses a zero-padded bib number (001, 002, ...).
 */
export async function addTestEntries(page, count = 3) {
  for (let i = 1; i <= count; i++) {
    await page.keyboard.press('Delete');
    const bib = String(i).padStart(3, '0');
    for (const digit of bib) {
      await page.keyboard.press(digit);
    }
    await page.click('#radial-time-btn');
    await waitForConfirmationToHide(page);
  }
}
