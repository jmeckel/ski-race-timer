# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Ski Race Timer is a GPS-synchronized race timing Progressive Web App (PWA) for ski races. It's a TypeScript single-page application designed for mobile use in outdoor race conditions.

## Commands

- **Start dev server**: `npm start` or `npm run dev`
- **Build**: `npm run build` (TypeScript compilation + Vite build)
- **Run tests**: `npm test` (unit tests) or `npm run test:e2e` (Playwright E2E tests)
- **Type check**: `npm run typecheck`

## Architecture

### Source Structure

```
.
├── api/                    # Vercel serverless functions (v1)
│   ├── v1/                 # Versioned API endpoints
│   │   ├── auth/
│   │   │   └── token.js   # JWT token exchange endpoint
│   │   ├── admin/
│   │   │   ├── races.js   # Race management API
│   │   │   ├── pin.js     # PIN management API
│   │   │   └── reset-pin.js # PIN reset (server-side auth)
│   │   ├── sync.js        # Cloud sync API
│   │   └── faults.js      # Fault entries API
│   └── lib/
│       ├── jwt.js         # Shared JWT utilities
│       └── response.js    # Shared API response utilities
├── src/
│   ├── app.ts             # Main application logic
│   ├── main.ts            # App entry point and initialization
│   ├── onboarding.ts      # First-run onboarding wizard
│   ├── version.ts         # Version codenames and per-release changelogs
│   ├── store/             # State management (Zustand-like)
│   ├── services/          # GPS, sync, camera, feedback services
│   ├── components/        # UI components (Clock, VirtualList, Toast)
│   ├── features/          # Feature modules (modals, ripple, export)
│   ├── utils/             # Validation, error handling, API utilities
│   ├── i18n/              # Translations (EN/DE)
│   ├── styles/            # CSS stylesheets
│   └── types/             # TypeScript type definitions
├── public/
│   ├── icons/             # App icons (72-512px PNG)
│   ├── manifest.json      # PWA manifest
│   └── sw.js              # Service worker (auto-generated by VitePWA)
├── tests/
│   ├── api/               # API unit tests (Vitest)
│   ├── unit/              # Component/service unit tests
│   └── e2e/               # Playwright E2E tests
└── index.html             # Entry point
```

### Key Components

The app has three tab-based views:
1. **Timer** - Radial dial interface (iPod-style) for bib input, real-time clock display, timing point selection (S/Z), run selection (L1/L2)
2. **Results** - List of recorded times with run indicator, CSV export (Race Horology format), entry editing/deletion, photo thumbnails
3. **Settings** - GPS sync, cloud sync, auto-increment bib, haptic/sound feedback, language toggle (EN/DE), photo capture, race management

### Radial Dial Timer (iPod-style Interface)

The timer view uses a radial dial interface inspired by the iPod click wheel. Located in:
- `src/components/RadialDial.ts` - Core dial component with touch/mouse handling
- `src/features/radialTimerView.ts` - View logic, state management, timestamp recording
- `src/styles/radial-dial.css` - All styling for the radial interface

**Key Features:**
- **Tap-to-enter**: Tap a number (0-9) to append it to the bib
- **Spin-to-increment**: Drag around the dial to increment/decrement the bib number
- **Momentum physics**: Dial continues spinning with friction after release
- **Snap-back**: Dial returns to starting position after 800ms of inactivity
- **Timing point selector**: S (Start) / Z (Ziel/Finish) buttons on left side of dial center
- **Run selector**: L1/L2 buttons on right side of dial center
- **Keyboard shortcuts**: Number keys, S/F for points, Space/Enter for timestamp

**Technical Implementation:**
- Numbers positioned at `radius = containerSize * 0.38` from center
- Dial center is 52% of container size, uses `pointer-events: none` with nested buttons having `pointer-events: auto`
- Tap detection uses angle-based calculation (not `document.elementFromPoint`) to work reliably after dial rotation
- Center exclusion zone (`dist < rect.width * 0.27`) prevents drag initiation when tapping S/Z or L1/L2 buttons
- Synthetic mouse events after touch are ignored for 500ms to prevent duplicate inputs

**CSS Structure:**
```css
.timer-view.radial-mode.active { /* Grid layout for radial view */ }
.dial-container { width: 100vw; height: 100vw; }
.dial-center { width: 52%; height: 52%; /* Contains time display, S/Z, L1/L2 */ }
.dial-number { /* Positioned absolutely around dial ring */ }
```

### Gate Judge - Gate-First Quick Entry

The gate judge view uses a "gate-first" quick entry pattern. Located in:
- `src/features/faultEntry.ts` - Inline fault entry logic, gate grid rendering, save flow
- `src/features/gateJudgeView.ts` - View initialization, gate assignment, ready status
- `src/styles/main.css` - Gate grid and fault detail panel styles

**Design Principle - Gate-First:**
Gates are the PRIMARY UI element because real ski gate judges watch specific gates and see faults happen at them. The flow is: tap gate -> select fault type -> bib auto-fills -> save. This is a 2-tap minimum flow (gate + fault type) instead of the old 3-step bib-first flow.

**Layout (top to bottom):**
1. Header: gate range display, L1/L2 run selector, "Change" button
2. Gate Grid: 5-column grid of large, color-coded (red/blue) gate buttons with fault count badges
3. Fault Detail Panel: appears below gates after selecting a gate, contains fault type selector + bib selector
4. Recorded Faults: compact scrollable list of recorded faults
5. Footer: "Save Fault" button + "Ready" toggle (thumb-reachable at bottom)

**Thumb-Reachable Principle:**
Primary action buttons (Save Fault, Ready) are positioned at the bottom of the viewport for one-handed phone operation. This is critical for gate judges who may be holding equipment or wearing gloves.

**Key Implementation Details:**
- Gate grid uses CSS Grid with `grid-template-columns: repeat(5, 1fr)`
- Gate buttons show fault count badges (absolute positioned) when faults exist for that gate
- Tapping a gate reveals the fault detail panel and auto-selects the most recently started bib
- Tapping the same gate again deselects it and hides the detail panel
- After saving a fault, gate and bib remain selected for quick successive faults
- Only the fault type resets after save

**CSS Structure:**
```css
.gate-first-layout { /* flex column, scrollable */ }
.gate-grid { grid-template-columns: repeat(5, 1fr); gap: 8px; }
.gate-grid-btn { height: 56px; /* large touch targets */ }
.gate-grid-btn.red { color: var(--error); }
.gate-grid-btn.blue { color: var(--primary); }
.fault-detail-panel { /* expandable section below gates */ }
.gate-judge-footer { /* sticky at bottom, thumb-reachable */ }
```

### Data Storage

- **LocalStorage keys**:
  - `skiTimerEntries` - Race timing entries
  - `skiTimerSettings` - User settings
  - `skiTimerAuthToken` - JWT authentication token
  - `skiTimerRaceId` - Current race ID
  - `skiTimerDeviceId` - Unique device identifier
  - `skiTimerRecentRaces` - Recently synced races (for quick-select)

- **Entry format**: `{ id, bib, point: 'S'|'F', run: 1|2, timestamp, status, deviceId, deviceName, photo? }`
- **Entry status values**: `ok` (normal), `dns` (did not start), `dnf` (did not finish), `dsq` (disqualified), `flt` (finished with fault penalty for U8/U10 categories)

### Feature Modules

Located in `src/features/`, these modules organize UI functionality by domain:

**View modules** (extracted from app.ts):
- **radialTimerView.ts** (~600 lines) - Radial dial timer interface, clock display, timestamp recording
- **timerView.ts** (~470 lines) - Classic timer view (hidden when radial mode active)
- **resultsView.ts** (~250 lines) - VirtualList, filtering, search, pull-to-refresh
- **settingsView.ts** (~550 lines) - Settings toggles, role selection, recent races
- **gateJudgeView.ts** (~350 lines) - Gate judge UI, gate assignment, ready status
- **chiefJudgeView.ts** (~630 lines) - Chief judge panel, fault summaries, deletion approvals
- **faultEntry.ts** (~950 lines) - Fault recording, editing, inline entry, deletion workflow
- **raceManagement.ts** (~950 lines) - PIN management, race CRUD, auth handling

**Utility modules**:
- **modals.ts** - Modal open/close utilities with animation support
- **ripple.ts** - Material Design ripple effect for touch feedback
- **export.ts** - CSV export in Race Horology format
- **photoViewer.ts** (~100 lines) - Photo viewing and deletion from IndexedDB

**CustomEvent pattern**: Modules communicate via CustomEvents for decoupled architecture:
```typescript
// In feature module: dispatch event
const event = new CustomEvent('fault-edit-request', {
  bubbles: true,
  detail: { fault }
});
element.dispatchEvent(event);

// In app.ts: listen for events
document.addEventListener('fault-edit-request', (e: CustomEvent) => {
  openFaultEditModal(e.detail.fault);
});
```

### Utility Modules

Located in `src/utils/`:
- **recentRaces.ts** - Track recently synced races for quick-select dropdown
- **errorBoundary.ts** - Global error handling and user-friendly error display
- **api.ts** - Centralized API client with auth headers
- **validation.ts** - Input validation for race IDs, entries, etc.
- **errors.ts** - Structured error logging
- **format.ts** - Time, date, and number formatting utilities

### Multi-Device Sync

Cross-device sync uses Redis (via ioredis) with polling:
- **API endpoint**: `/api/v1/sync` handles GET (fetch), POST (add), DELETE (remove)
- **Polling interval**: 5 seconds (30 seconds on error)
- **BroadcastChannel**: Used for same-browser tab sync
- **Race ID**: Case-insensitive unique identifier to group synced devices

### Authentication

JWT-based authentication protects sync and admin APIs:

1. **Token Exchange**: User enters 4-digit PIN → `/api/v1/auth/token` returns JWT
2. **Token Storage**: JWT stored in localStorage (`skiTimerAuthToken`)
3. **Token Usage**: API calls include `Authorization: Bearer <token>` header
4. **Token Expiry**: 24-hour expiry, auto-prompts re-authentication
5. **Backwards Compatible**: Legacy PIN hash still accepted for migration

### Role-Based Access Control

JWT tokens include a `role` claim for authorization:

| Role | Description | Permissions |
|------|-------------|-------------|
| `timer` | Default role for timing devices | Read/write entries and faults |
| `gateJudge` | Gate judge devices | Read/write entries and faults |
| `chiefJudge` | Chief judge with elevated privileges | All above + **delete faults** |

- **Fault deletion** requires `chiefJudge` role (server-side enforced)
- Role is specified when exchanging PIN for token: `{ pin: "1234", role: "chiefJudge" }`
- Entering Chief Judge mode in the UI triggers re-authentication with `chiefJudge` role

### CSV Export Format (Race Horology)

Exports use semicolon delimiter and standard timing designators:
- **Columns**: Startnummer, Lauf, Messpunkt, Zeit, Status, Gerät
- **Timing Points**: ST (Start), FT (Finish)
- **Run (Lauf)**: 1 or 2 for multi-run races
- **Time Format**: HH:MM:SS.ss (hundredths of seconds)
- **CSV Injection Protection**: Formula characters escaped with single quote prefix

## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `REDIS_URL` | Yes | Redis connection URL (Vercel KV or external Redis) |
| `JWT_SECRET` | **Production** | Secret for signing JWT tokens. **Required in production** - will fail to start without it. |
| `CORS_ORIGIN` | No | Allowed CORS origin (defaults to production domain) |

## API Endpoints

All endpoints use the `/api/v1/` prefix. Legacy `/api/*` paths are rewritten to v1 for backwards compatibility.

### `/api/v1/auth/token` (POST)
Exchange PIN for JWT token with optional role.
- **Body**: `{ pin: "1234", role?: "timer" | "gateJudge" | "chiefJudge" }`
- **Response**: `{ success: true, token: "jwt...", role: "timer", isNewPin?: true }`
- **Default role**: `timer` if not specified

### `/api/v1/sync` (GET/POST/DELETE)
Cloud sync for race entries. Requires JWT token when PIN is set.
- **GET**: Fetch entries for race
- **POST**: Add/update entry
- **DELETE**: Remove entry

### `/api/v1/faults` (GET/POST/DELETE)
Fault entries for gate judges. Requires JWT token.
- **GET**: Fetch faults for race (any authenticated role)
- **POST**: Add/update fault entry (any authenticated role)
- **DELETE**: Remove fault entry (**requires `chiefJudge` role**, returns 403 otherwise)

### `/api/v1/admin/races` (GET/DELETE)
Race management. Requires JWT token.
- **GET**: List all races with metadata
- **DELETE**: Delete race and set tombstone for connected clients

### `/api/v1/admin/pin` (GET/POST)
PIN hash management. Requires JWT token.
- **GET**: Get current PIN hash status
- **POST**: Set PIN hash

### `/api/v1/admin/reset-pin` (POST)
Reset PIN (server-side authentication via request body).
- **Body**: `{ serverPin: "<server-pin>" }`
- **Response**: `{ success: true, message: "PIN has been reset..." }`

## Testing

```bash
# Unit tests (Vitest)
npm test

# E2E tests (Playwright)
npm run test:e2e

# E2E with browser visible
npm run test:e2e:headed

# All tests
npm run test:all
```

## Vercel Deployment

1. Connect repository to Vercel
2. Add Vercel KV (Storage → Create Database → KV)
3. Set `JWT_SECRET` environment variable in Vercel dashboard
4. Deploy - environment variables auto-configured

## Version Management

**Always bump the version number in `package.json` after completing features or fixes.**

Follow semantic versioning (MAJOR.MINOR.PATCH):
- **PATCH** (x.x.1): Bug fixes, small tweaks, typo corrections
- **MINOR** (x.1.0): New features, enhancements, non-breaking changes
- **MAJOR** (1.0.0): Breaking changes, major rewrites, significant API changes

Examples:
- Single bug fix → bump patch (4.1.0 → 4.1.1)
- New feature like "Gate Judge" → bump minor (4.0.0 → 4.1.0)
- Complete rewrite or breaking change → bump major (4.1.0 → 5.0.0)

Commit the version bump separately with a message like "Bump version to X.Y.Z" summarizing what changed.

### Version Codenames & Changelogs

Each **minor** release gets a dessert+animal codename and a short end-user changelog displayed in the settings screen. These are defined in `src/version.ts`.

**When bumping to a new minor version**, add an entry to `VERSION_NAMES` in `src/version.ts`:

```typescript
const VERSION_NAMES: Record<string, VersionInfo> = {
  '5.18': {
    name: 'Tiramisu Fox',
    description: {
      en: 'Battery power saver for longer outdoor timing. Improved PIN security and faster voice notes.',
      de: 'Batterieschoner für längere Zeitmessung im Freien. Verbesserte PIN-Sicherheit und schnellere Sprachnotizen.'
    }
  },
  '5.19': {
    name: 'Waffle Owl',   // Pick a unique dessert + animal combo
    description: {
      en: '1-2 sentences describing user-facing changes.',
      de: 'German translation of the same.'
    }
  }
};
```

**Rules:**
- **Key**: Minor version only (e.g. `"5.19"`) — all patches under that minor share the same codename
- **Name**: `"Dessert Animal"` format, both capitalized, unique per release. Keep it fun but professional.
- **Description**: 1-2 sentences, end-user wording (not developer jargon). Must have both `en` and `de` translations.
- **Patch-only bumps**: No new entry needed — the existing minor entry covers all patches.
- **Display**: Settings screen shows `Version X.Y.Z "Name"` with the description below. The name also appears in clipboard debug info.

**Files involved in version display:**
- `src/version.ts` — Codename map and `getVersionInfo()` lookup
- `index.html` — `#app-version-name` and `#app-version-description` elements inside `#version-info-btn`
- `src/app.ts` — Populates name + description on init, includes name in debug info
- `src/features/settingsView.ts` — Updates description in `updateTranslations()` on language switch
- `src/styles/main.css` — `.version-name` (primary color) and `.version-description` (tertiary, small) styles

## Feature Completion Checklist

When completing a feature, always run through this checklist before marking done:

1. **Run tests**: `npm test` for unit tests, `npm run test:e2e` for E2E tests
2. **Check for TypeScript errors**: `npm run typecheck`
3. **Test in browser if UI-related**: Verify visual appearance and interactions work correctly
4. **Update relevant documentation**: README, CLAUDE.md, inline comments as needed

## Deployment

For sessions involving deployment: complete all code changes and reviews BEFORE starting deployment steps. Do not interleave deployment with bug fixes.

**Deployment workflow:**
1. Finish all code changes
2. Run the Feature Completion Checklist above
3. Commit all changes
4. Only then proceed with deployment steps

## Code Review

When asked to "review the app" or similar broad requests, first propose a structured review plan with specific areas to check, then get user confirmation before starting.

**Review plan template:**
1. Define scope: What areas/files will be reviewed?
2. Define criteria: What are we checking for? (security, accessibility, performance, etc.)
3. Define out-of-scope: What should be noted but NOT fixed in this review?
4. Get user confirmation before starting

This prevents scope creep mid-review and ensures focused, actionable findings.

## Key Implementation Details

- **Translations**: In `src/i18n/translations.ts`, toggled via language setting. Default: German
  - Use `data-i18n` attribute on HTML elements for automatic translation
  - Short keys like `startShort`/`finishShort` for compact UI (S/F in English, S/Z in German)
  - Translations interface uses `[key: string]: string` index signature for flexibility
  - `updateTranslations()` in `settingsView.ts` scans all `[data-i18n]` elements and applies translations
  - For dynamic content in TypeScript, use `t('key', lang)` where `lang = store.getState().currentLang`
  - Aria-labels in templates need translation: ``aria-label="${t('deleteLabel', lang)}"``
  - Add new keys to BOTH `en:` and `de:` sections in translations.ts
- **Onboarding**: First-run wizard in `src/onboarding.ts` guides users through setup
  - Skip button allows dismissing at any time while saving progress (device name, role)
  - Completed state stored in localStorage (`skiTimerOnboarding`)
- **GPS sync**: Uses Geolocation API for real GPS timestamps
- **Haptic feedback**: Uses Navigator.vibrate() API
- **Sound feedback**: Uses Web Audio API for beep sounds
- **Photo capture**: Optional photo on timestamp, synced if <500KB
- **Mobile optimization**: Safe area insets for notches, touch-optimized, portrait lock
- **Service Worker**: Auto-generated by VitePWA with content-based versioning (no manual version bumps)
- **Error Handling**: Global error boundary catches uncaught errors with user-friendly recovery UI
- **TypeScript**: Strict mode enabled for better type safety
- **Motion effects**: Settings exist but currently disabled to save battery (see `src/main.ts:3-4`). The motion service uses device accelerometer for reactive UI effects.
- **Environment-aware logging**: Use `src/utils/logger.ts` - strips debug logs in production, keeps errors/warnings

## Security Best Practices

### XSS Prevention
- **Always use `escapeHtml()`** from `src/utils/format.ts` when inserting dynamic content into `innerHTML`
- This includes: bib numbers, device names, race IDs, gate numbers, any user-controlled data
- For `data-*` attributes and other HTML attributes, use `escapeAttr()`: `data-bib="${escapeAttr(bib)}"`
- Prefer `textContent` over `innerHTML` when not rendering HTML markup

### Example patterns:
```typescript
// GOOD: escaped for HTML content
element.innerHTML = `<span>${escapeHtml(userInput)}</span>`;

// GOOD: escaped for HTML attributes (includes quote escaping)
element.innerHTML = `<div title="${escapeAttr(userInput)}">...</div>`;

// BAD: vulnerable to XSS
element.innerHTML = `<span>${userInput}</span>`;

// BAD: escapeHtml doesn't escape quotes for attributes
element.innerHTML = `<div title="${escapeHtml(userInput)}">...</div>`;
// Input: `" onmouseover="alert(1)` breaks out of attribute
```

### Security Headers
Configure in `vercel.json` for defense in depth:
```json
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        { "key": "X-Content-Type-Options", "value": "nosniff" },
        { "key": "X-Frame-Options", "value": "DENY" },
        { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" }
      ]
    }
  ]
}
```

## Browser API Error Handling

### User Notification on Silent Failures
Browser APIs often fail silently. Critical features should notify users:

```typescript
// Example: Wake Lock failure notification
try {
  this.wakeLock = await navigator.wakeLock.request('screen');
} catch (err) {
  // API failed - notify user about the impact
  const lang = store.getState().currentLang;
  showToast(t('wakeLockFailed', lang), 'warning', 5000);
}
```

**APIs that need failure notifications:**
- **Wake Lock**: Screen may dim during timing
- **GPS**: Location unavailable, times may be less accurate
- **Camera**: Photo capture disabled
- **Microphone**: Voice commands unavailable

### Cleanup on Error Paths
When registering handlers before an async operation, clean up if it fails:

```typescript
// Register handler
this.visibilityHandler = () => { ... };
document.addEventListener('visibilitychange', this.visibilityHandler);

try {
  await someAsyncOperation();
} catch (error) {
  // Clean up handler registered before the error
  document.removeEventListener('visibilitychange', this.visibilityHandler);
  this.visibilityHandler = null;
  throw error;
}
```

## Memory Management

### Event Listener Cleanup
Components that add event listeners MUST remove them in `destroy()`:
```typescript
// In constructor/init:
this.container.addEventListener('mousedown', this.handleDragStart);
window.addEventListener('resize', this.handleResize);

// In destroy():
this.container.removeEventListener('mousedown', this.handleDragStart);
window.removeEventListener('resize', this.handleResize);
```

### Store Subscription Cleanup
Components subscribing to store updates MUST unsubscribe when destroyed:
```typescript
// Subscribe
this.unsubscribe = store.subscribe((state, keys) => { ... });

// In destroy():
if (this.unsubscribe) {
  this.unsubscribe();
  this.unsubscribe = null;
}
```

### DOM Removal Detection
For components that might be removed from DOM without explicit `destroy()` call, use MutationObserver:
```typescript
this.domRemovalObserver = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    for (const removedNode of mutation.removedNodes) {
      if (removedNode.contains?.(this.container)) {
        this.destroy();
        return;
      }
    }
  }
});
this.domRemovalObserver.observe(this.container.parentElement, { childList: true, subtree: true });
```

### Double-Destruction Guard
Always guard against `destroy()` being called multiple times:
```typescript
private isDestroyed = false;

destroy(): void {
  if (this.isDestroyed) return;
  this.isDestroyed = true;
  // ... cleanup code
}
```

## Accessibility

### ARIA Attributes for Interactive Elements
All interactive elements must be accessible to screen readers:

```html
<!-- Icon-only buttons need aria-label -->
<button class="clear-btn" aria-label="Clear bib number">C</button>

<!-- SVGs inside buttons need aria-hidden -->
<button class="time-btn" aria-label="Record timestamp">
  <svg aria-hidden="true" ...></svg>
</button>

<!-- Dropdowns need expanded state and popup type -->
<button class="dropdown-btn" aria-label="Recent races" aria-expanded="false" aria-haspopup="listbox">
  <svg aria-hidden="true" ...></svg>
</button>

<!-- Toggle buttons need aria-pressed -->
<button class="ready-toggle-btn" aria-pressed="false">Ready</button>
```

### Radio Group Pattern
For mutually exclusive selections (timing points, runs, roles), use radio group semantics:

```html
<!-- Container with radiogroup role -->
<div class="timing-point" role="radiogroup" aria-label="Timing point">
  <button class="point-btn" role="radio" aria-checked="false" data-point="S">S</button>
  <button class="point-btn active" role="radio" aria-checked="true" data-point="F">F</button>
</div>
```

```typescript
// Update aria-checked when selection changes
function updateSelection(): void {
  container.querySelectorAll('.point-btn').forEach(btn => {
    const isActive = btn.getAttribute('data-point') === state.selectedPoint;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-checked', String(isActive));
  });
}
```

### Updating Dynamic ARIA States
When dropdown/menu state changes, update `aria-expanded`:
```typescript
dropdownBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
```

### Keyboard Navigation

#### General Principles
- All clickable elements must be focusable (buttons are by default)
- Custom controls should support keyboard interaction (Space/Enter to activate)
- Focus should be trapped in modals when open
- Modals should dismiss with Escape key

#### Tab Navigation (WCAG 2.1 Compliant)
For tab-like controls, implement arrow key navigation:
```typescript
btn.addEventListener('keydown', (e: KeyboardEvent) => {
  const tabs = Array.from(container.querySelectorAll('.tab-btn')) as HTMLElement[];
  const currentIndex = tabs.indexOf(btn);
  let newIndex = currentIndex;

  switch (e.key) {
    case 'ArrowLeft':
    case 'ArrowUp':
      e.preventDefault();
      newIndex = currentIndex > 0 ? currentIndex - 1 : tabs.length - 1;
      break;
    case 'ArrowRight':
    case 'ArrowDown':
      e.preventDefault();
      newIndex = currentIndex < tabs.length - 1 ? currentIndex + 1 : 0;
      break;
    case 'Home':
      e.preventDefault();
      newIndex = 0;
      break;
    case 'End':
      e.preventDefault();
      newIndex = tabs.length - 1;
      break;
  }

  if (newIndex !== currentIndex) {
    tabs[newIndex].focus();
    tabs[newIndex].click(); // Activate tab on focus
  }
});
```

#### List Navigation
For navigable lists (results, dropdowns), implement arrow key navigation:
```typescript
item.addEventListener('keydown', (e: KeyboardEvent) => {
  switch (e.key) {
    case 'Enter':
    case ' ':
      e.preventDefault();
      selectItem(item);
      break;
    case 'ArrowDown':
      e.preventDefault();
      focusNextItem(item);
      break;
    case 'ArrowUp':
      e.preventDefault();
      focusPreviousItem(item);
      break;
    case 'Escape':
      e.preventDefault();
      closeDropdown();
      break;
  }
});
```

#### Keyboard Shortcuts
Provide keyboard shortcuts for common actions:
```typescript
// Fault type shortcuts: M/G=MG, T=STR, B/R=BR
const key = event.key.toUpperCase();
switch (key) {
  case 'M':
  case 'G':
    selectFaultType('MG');
    break;
  case 'T':
    selectFaultType('STR');
    break;
  case 'B':
  case 'R':
    selectFaultType('BR');
    break;
}

// Run selection: Alt+1, Alt+2
if (e.altKey && (e.key === '1' || e.key === '2')) {
  e.preventDefault();
  store.setSelectedRun(e.key === '1' ? 1 : 2);
}
```

### Custom Interactive Elements
For non-button elements that respond to click, add full keyboard support:
```typescript
el.setAttribute('tabindex', '0');
el.setAttribute('role', 'button');
el.setAttribute('aria-label', 'Description of action');
el.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    handleClick();
  }
});
```

### Focus Indicators
All interactive elements need visible focus indicators:
```css
/* Add to focus-visible selector list in main.css */
.my-interactive-element:focus-visible {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}
```

### Focus Management
After showing overlays or modals, focus the first interactive element:
```typescript
document.body.appendChild(overlay);
setTimeout(() => {
  document.getElementById('dismiss-btn')?.focus();
}, 100);
```

## State Management Notes

### Notification Queue Race Conditions
The store uses a notification queue to handle re-entrant state changes. Key rules:
- Each notification captures its state snapshot at the time of the change
- Don't merge state snapshots when coalescing - only merge the changed key arrays
- The queue has a safety limit (`MAX_NOTIFICATION_QUEUE`) that drains oldest notifications when exceeded

## Key Learnings (Code Review Findings)

These patterns emerged from comprehensive code reviews. Organized by category for quick reference.

### Security

| Rule | Description |
|------|-------------|
| **Escape all innerHTML** | Always use `escapeHtml()` for content, `escapeAttr()` for attributes. Even "safe" data like bib numbers should be escaped (defense in depth). |
| **Escape data attributes** | `data-*` attributes with user data need `escapeAttr()`: `setAttribute('data-id', escapeAttr(id))` |
| **Fail closed on errors** | Rate limiting, auth, and security features must deny access when backing services fail. Grep for `allowed: true` in catch blocks. |
| **Fail closed on missing deps** | If auth requires Redis/DB and it's unavailable, return 503—never skip auth. Pattern: `if (!client) return sendServiceUnavailable()` not `if (client) { checkAuth() }`. |
| **Remove deprecated auth** | Don't mark legacy auth as deprecated—remove it entirely. Old paths create vulnerabilities. |
| **No hardcoded default PINs** | Never auto-authenticate with a default PIN constant. If no PIN exists, require user to set one explicitly. |
| **PBKDF2 for PIN hashing** | Use PBKDF2 (100k+ iterations, random salt) not SHA-256 for PINs. Format: `salt:hash` (hex). Legacy detection: `storedHash.includes(':')`. |
| **Timing-safe PIN comparison** | Always use `crypto.timingSafeEqual()` for PIN verification, even with PBKDF2. |
| **CSP: no unsafe-inline** | Verify no inline `<script>` tags exist before removing `'unsafe-inline'` from `script-src`. Vite injects module scripts via `src=` attributes, not inline. |
| **Secrets in body, not headers** | Headers are logged by proxies/CDNs. Send PINs, API keys in request body over HTTPS. |
| **Security headers** | Add `X-Content-Type-Options: nosniff`, `X-Frame-Options: DENY`, `Referrer-Policy` in vercel.json. |

### Memory Management

| Rule | Description |
|------|-------------|
| **Full listener cleanup** | `destroy()` must remove ALL listeners—container, window, document, and per-element. |
| **Track listeners in Maps** | For dynamic elements, use `Map<HTMLElement, EventListener>` to enable removal. Anonymous functions can't be removed. |
| **Double-destruction guard** | Add `isDestroyed` flag, check at start of `destroy()`. Multiple calls can occur. |
| **MutationObserver for auto-cleanup** | Watch for DOM removal when components might be removed without `destroy()`. |
| **Clear all timeouts** | Track setTimeout IDs in a Set, clear all in `destroy()`. |
| **Clean up dynamic styles** | Remove `<style>` elements appended to `document.head` in `destroy()`. |
| **Cleanup on error paths** | If registering listeners before async ops, clean up in catch block too. |

### Accessibility

| Rule | Description |
|------|-------------|
| **Icon buttons need aria-label** | `<button aria-label="Clear">C</button>` |
| **SVGs need aria-hidden** | `<svg aria-hidden="true">` inside buttons |
| **Decorative icons need aria-hidden** | Checkmarks (✓), emojis, status icons: `aria-hidden="true"` |
| **Dropdowns need aria-expanded** | Update `aria-expanded="true/false"` on state change |
| **Radio groups** | Wrap in `role="radiogroup"`, options get `role="radio"` + `aria-checked` |
| **Dynamic content needs aria-live** | `aria-live="polite"` on status indicators, loading states, lists |
| **Custom elements need full support** | `tabindex="0"`, `role="button"`, `aria-label`, Enter/Space handler |
| **Focus management** | Focus first interactive element after showing modal/overlay |
| **Use :focus-visible** | Not `:focus`—shows rings only for keyboard nav |
| **Arrow keys for tabs** | Tab key moves between components; arrow keys move within |

### Internationalization

| Rule | Description |
|------|-------------|
| **All text needs translations** | Check: innerHTML, textContent, aria-label, title, placeholder |
| **Aria-labels need translation** | Use `t()` in templates: `` aria-label="${t('key', lang)}" `` |
| **Use data-i18n-aria-label** | For static HTML aria-labels that can't use `t()` |
| **Check for existing keys** | Grep before adding—"close", "cancel" etc. likely exist. Duplicates cause TS errors. |
| **Pluralization needs separate keys** | `timeEntry`/`timeEntries`, select with: `t(count === 1 ? 'timeEntry' : 'timeEntries', lang)` |
| **Import store and t()** | Components displaying text need both for `currentLang` access |

### Modal & Overlay Patterns

| Rule | Description |
|------|-------------|
| **ESC key dismissal** | Standard UX—add keydown listener for Escape |
| **Click-outside dismissal** | Check `e.target === overlay` to dismiss only on backdrop click |
| **ESC handler conflicts** | Check `overlay.classList.contains('show') && !isAnyModalOpen()` |
| **Close button (X) handlers** | Easy to miss—add click handler for header close button |
| **Auto-focus button** | `setTimeout(() => doneBtn?.focus(), 100)` after showing |
| **Clean up previous listeners** | Store refs at module level, remove at start of open function |

### Error Handling

| Rule | Description |
|------|-------------|
| **Notify on silent API failures** | Wake Lock, GPS, Camera, Mic—show toast when unavailable |
| **Warn about deferred validation** | "PIN will be verified when online" when skipping offline |
| **Show loading states** | Spinner/text before async ops, results/errors after |
| **Wrap init chains in try-catch** | One failure shouldn't prevent other init steps |
| **Always add .catch()** | Even fire-and-forget promises need `.catch(err => logger.error(err))` |
| **Browser API init needs .catch()** | `batteryService.initialize().then(...)` MUST have `.catch(() => { /* fallback */ })`. Battery API, Wake Lock, etc. may reject. |
| **Defensive BroadcastChannel** | Use `event.data || {}`, wrap in try-catch |
| **Return result objects** | `{ success: true }` or `{ success: false, error }` not void/throw |

### State & Events

| Rule | Description |
|------|-------------|
| **Capture snapshots immediately** | In notification systems, snapshot at change time, not processing time |
| **Queue bounds check before push** | Check and drain before every push, not just conditionally |
| **Use CustomEvents** | `bubbles: true` for cross-module communication, avoids circular deps |
| **Dispatch error events** | `fault-sync-error` etc. so UI can update indicators |
| **Clear debounce on direct call** | If `applyFilters()` calls `render()`, clear pending debounced render |

### Animation

| Rule | Description |
|------|-------------|
| **Separate RAF IDs per animation type** | `spinAnimationId`, `snapBackAnimationId`—cancel both on new interaction |
| **Check RAF ID before recovery** | `if (animationId === null)` before scheduling to prevent duplicate loops |
| **RAF over setInterval for display** | Use `requestAnimationFrame` for clock/UI updates, not `setInterval(fn, 16)`. RAF pauses when tab hidden (saves battery), aligns with vsync. |
| **Battery-aware frame skipping** | Subscribe to battery service; skip frames on low battery (e.g., `frameSkip=1` for 30fps, `frameSkip=3` for 15fps). |
| **Pause RAF on hidden** | Add `visibilitychange` listener to cancel RAF when `document.hidden`, restart when visible. |

### Performance

| Rule | Description |
|------|-------------|
| **Cache DOM queries used per-frame** | Store `querySelectorAll` results in arrays/Maps during init, not in animation loops. `cachedNumberSpans[]` vs `querySelectorAll('.dial-number span')` per frame. |
| **Dirty-slice persistence** | Track which state slices changed with a `Set<string>`. Only serialize dirty slices to localStorage. Add early return: `if (dirty.size === 0) return`. |
| **Suspend idle AudioContext** | Call `audioContext.suspend()` after 30s idle. Resume before playing: `if (ctx.state === 'suspended') ctx.resume()`. Saves power on mobile. |

### Power Optimization

| Rule | Description |
|------|-------------|
| **CSS .power-saver class** | Toggle `document.body.classList.toggle('power-saver', lowBattery)` to disable CSS infinite animations (`animation: none !important`). |
| **Battery service subscription** | Use `batteryService.initialize().then(() => subscribe(...)).catch(() => {})` for graceful degradation. |

### Code Quality

| Rule | Description |
|------|-------------|
| **Check existing variables** | Before adding `const lang = ...`, check if `lang` exists in scope |
| **Validate parameters defensively** | Check IDs exist and are correct type before using |
| **Array bounds validation** | Use `config.intervals?.[index] ?? fallback` |
| **Use data structures over DOM queries** | Component's Map is O(1); `querySelectorAll` is expensive |
| **Semantic HTML** | `<dl>/<dt>/<dd>` for label-value pairs conveys meaning to screen readers |
| **Version history completeness** | `extractVersionData()` must include ALL editable fields |

### Testing

| Rule | Description |
|------|-------------|
| **Test real crypto, not mocks** | Existing `auth-token.test.js` mocks `hashPin` with SHA-256. New crypto tests in `pin-hashing.test.js` test the real PBKDF2 implementation. Always test actual crypto functions. |
| **Test migration paths** | When changing data formats (SHA-256 → PBKDF2), test that both old and new formats work: `verifyPin(pin, legacyHash)` AND `verifyPin(pin, pbkdf2Hash)`. |
| **Test fail-closed patterns** | Security auth tests must verify the **absence** of access when deps are down, not just presence of auth when deps are up. |
| **Test dirty-slice isolation** | When optimizing persistence, verify that changing slice A does NOT trigger serialization of slice B. Check `localStorage.setItem` call arguments. |
| **Source code assertion tests** | When full handler integration tests are impractical (complex deps), read source with `fs.readFileSync` and assert patterns: `expect(source).toContain('failClosedPattern')`. |

## Animation Patterns

### Multiple Animation Types
When a component has different animation modes (e.g., momentum vs snap-back), track them separately:
```typescript
private spinAnimationId: number | null = null;
private snapBackAnimationId: number | null = null;

// When starting new interaction, cancel BOTH
if (this.spinAnimationId) cancelAnimationFrame(this.spinAnimationId);
if (this.snapBackAnimationId) cancelAnimationFrame(this.snapBackAnimationId);
```

### RAF Error Recovery
When recovering from errors in RAF loops, prevent duplicate loops:
```typescript
} catch (error) {
  logger.error('Tick error:', error);
  // Only schedule recovery if not already scheduled
  if (this.animationId === null) {
    this.animationId = requestAnimationFrame(this.tick);
  }
}
```

### Debounce + Direct Call Interaction
When a debounced function can also be called directly, clear pending debounce:
```typescript
applyFilters(): void {
  // Clear any pending debounced render
  if (this.scrollDebounceTimeout !== null) {
    clearTimeout(this.scrollDebounceTimeout);
    this.scrollDebounceTimeout = null;
  }
  // ... then render directly
  this.render();
}
```

## Radial Dial Development Notes

When working on the radial dial component, be aware of these common issues:

### Touch Event Handling
- **Synthetic mouse events**: After a touch event, browsers fire synthetic mouse events. Track `lastTouchTime` and ignore mouse events within 500ms of touch.
- **Pointer events**: The dial center has `pointer-events: none` to allow touch-through, but nested buttons (S/Z, L1/L2) need `pointer-events: auto`.
- **Event binding**: Events must be bound to the container (not gesture area) to catch interactions with number buttons.

### Tap Detection
- **Don't use `document.elementFromPoint`**: After dial rotation, the visual position of elements changes but `elementFromPoint` may not find them reliably.
- **Use angle-based detection**: Calculate the tap angle relative to dial center, subtract current rotation, then find the closest number within tolerance (20° = half of 36° spacing).

### State Management
- **Snap-back cleanup**: When snap-back animation completes, clear `spinAnimationId`, `isSpinning`, and remove `momentum` class.
- **Animation cancellation**: When starting a new drag/tap during animation, cancel the animation and reset `isSpinning`.

### Layout Considerations
- **Dial size**: Currently 100vw to fill screen width. Dial center at 52% leaves room for numbers at 38% radius.
- **Overlap prevention**: Use negative margins on `.radial-center-area` and constrained height on record button to prevent overlap.
- **Z-index layers**: dial-ring (base), dial-numbers (z-index: 10), dial-center (z-index: 15), top-row (z-index: 20)

### Landscape Mode Layout

In landscape orientation, the radial dial uses a completely different two-column layout:

**Structure:**
- **Left column**: Dial only (full viewport height, no header/tab bar constraints)
- **Right column**: Header → Bib input → Stats → Record button → Tab bar

**CSS Implementation** (in `src/styles/radial-dial.css`):
```css
/* Grid at .app level with display:contents to flatten hierarchy */
.app:has(.timer-view.radial-mode.active) {
  display: grid;
  grid-template-columns: auto 1fr;
  grid-template-rows: auto auto auto 1fr auto;
  column-gap: 16px;
}

/* Dissolve containers so children participate in parent grid */
.app:has(...) > #main { display: contents; }
.timer-view.radial-mode.active { display: contents; }
.radial-bottom-row { display: contents; }

/* Dial spans all rows in left column */
.radial-center-area { grid-column: 1; grid-row: 1 / -1; }

/* Right column elements placed in specific rows */
.header { grid-column: 2; grid-row: 1; }
.radial-top-row { grid-column: 2; grid-row: 2; }
.radial-stats-corner { grid-column: 2; grid-row: 3; }
.radial-time-btn-corner { grid-column: 2; grid-row: 4; }
.tab-bar { grid-column: 2; grid-row: 5; }
```

**Key techniques:**
- `display: contents` flattens DOM hierarchy allowing nested elements to participate in ancestor grid
- Dial size uses `min(100vh - 8px, 100dvh - 8px, 55vw)` to fit viewport height
- Header and tab bar only span right column, giving dial maximum vertical space
- Resize handler in `RadialDial.ts` regenerates number positions on orientation change

**Responsive breakpoints:**
- `@media (orientation: landscape)` - Base landscape layout
- `@media (orientation: landscape) and (max-height: 450px)` - Compact layout for short phones

## Keyboard Shortcuts Reference

The app supports full keyboard/USB numpad navigation:

### Timer View (Radial Dial)
| Key | Action |
|-----|--------|
| `0-9` | Enter bib number digit |
| `S` | Select Start timing point |
| `F` | Select Finish timing point |
| `Alt+1` | Select Run 1 |
| `Alt+2` | Select Run 2 |
| `Space` / `Enter` | Record timestamp |
| `Escape` / `Delete` | Clear bib input |
| `Backspace` | Delete last digit |

### Gate Judge (Fault Entry)
| Key | Action |
|-----|--------|
| `M` or `G` | Select Missed Gate (MG) |
| `T` | Select Straddled (STR) |
| `B` or `R` | Select Broken (BR) |
| `1-9`, `0` | Select gate number (0 = gate 10) |
| `Arrow keys` | Navigate between buttons |
| `Space` / `Enter` | Confirm selection |

### Results View
| Key | Action |
|-----|--------|
| `Arrow Up/Down` | Navigate between items |
| `Enter` / `Space` / `E` | Edit selected item |
| `Delete` / `D` | Delete selected item |

### Global
| Key | Action |
|-----|--------|
| `Tab` | Move to next component |
| `Shift+Tab` | Move to previous component |
| `Escape` | Close modal/dropdown |
| `Arrow keys` | Navigate within component |
