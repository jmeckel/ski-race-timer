# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Ski Race Timer is a GPS-synchronized race timing Progressive Web App (PWA) for ski races. It's a TypeScript single-page application designed for mobile use in outdoor race conditions.

## Commands

- **Start dev server**: `npm start` or `npm run dev`
- **Build**: `npm run build` (TypeScript compilation + Vite build)
- **Run tests**: `npm test` (unit tests) or `npm run test:e2e` (Playwright E2E tests)
- **Type check**: `npm run typecheck`

## Architecture

### Source Structure

```
.
‚îú‚îÄ‚îÄ api/                    # Vercel serverless functions (v1)
‚îÇ   ‚îú‚îÄ‚îÄ v1/                 # Versioned API endpoints
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ token.js   # JWT token exchange endpoint
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ admin/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ races.js   # Race management API
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pin.js     # PIN management API
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reset-pin.js # PIN reset (server-side auth)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sync.js        # Cloud sync API
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ faults.js      # Fault entries API
‚îÇ   ‚îî‚îÄ‚îÄ lib/
‚îÇ       ‚îú‚îÄ‚îÄ jwt.js         # Shared JWT utilities
‚îÇ       ‚îî‚îÄ‚îÄ response.js    # Shared API response utilities
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app.ts             # Main application logic
‚îÇ   ‚îú‚îÄ‚îÄ main.ts            # App entry point and initialization
‚îÇ   ‚îú‚îÄ‚îÄ onboarding.ts      # First-run onboarding wizard
‚îÇ   ‚îú‚îÄ‚îÄ store/             # State management (Zustand-like)
‚îÇ   ‚îú‚îÄ‚îÄ services/          # GPS, sync, camera, feedback services
‚îÇ   ‚îú‚îÄ‚îÄ components/        # UI components (Clock, VirtualList, Toast)
‚îÇ   ‚îú‚îÄ‚îÄ features/          # Feature modules (modals, ripple, export)
‚îÇ   ‚îú‚îÄ‚îÄ utils/             # Validation, error handling, API utilities
‚îÇ   ‚îú‚îÄ‚îÄ i18n/              # Translations (EN/DE)
‚îÇ   ‚îú‚îÄ‚îÄ styles/            # CSS stylesheets
‚îÇ   ‚îî‚îÄ‚îÄ types/             # TypeScript type definitions
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ icons/             # App icons (72-512px PNG)
‚îÇ   ‚îú‚îÄ‚îÄ manifest.json      # PWA manifest
‚îÇ   ‚îî‚îÄ‚îÄ sw.js              # Service worker (auto-generated by VitePWA)
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ api/               # API unit tests (Vitest)
‚îÇ   ‚îú‚îÄ‚îÄ unit/              # Component/service unit tests
‚îÇ   ‚îî‚îÄ‚îÄ e2e/               # Playwright E2E tests
‚îî‚îÄ‚îÄ index.html             # Entry point
```

### Key Components

The app has three tab-based views:
1. **Timer** - Radial dial interface (iPod-style) for bib input, real-time clock display, timing point selection (S/Z), run selection (L1/L2)
2. **Results** - List of recorded times with run indicator, CSV export (Race Horology format), entry editing/deletion, photo thumbnails
3. **Settings** - GPS sync, cloud sync, auto-increment bib, haptic/sound feedback, language toggle (EN/DE), photo capture, race management

### Radial Dial Timer (iPod-style Interface)

The timer view uses a radial dial interface inspired by the iPod click wheel. Located in:
- `src/components/RadialDial.ts` - Core dial component with touch/mouse handling
- `src/features/radialTimerView.ts` - View logic, state management, timestamp recording
- `src/styles/radial-dial.css` - All styling for the radial interface

**Key Features:**
- **Tap-to-enter**: Tap a number (0-9) to append it to the bib
- **Spin-to-increment**: Drag around the dial to increment/decrement the bib number
- **Momentum physics**: Dial continues spinning with friction after release
- **Snap-back**: Dial returns to starting position after 800ms of inactivity
- **Timing point selector**: S (Start) / Z (Ziel/Finish) buttons on left side of dial center
- **Run selector**: L1/L2 buttons on right side of dial center
- **Keyboard shortcuts**: Number keys, S/F for points, Space/Enter for timestamp

**Technical Implementation:**
- Numbers positioned at `radius = containerSize * 0.38` from center
- Dial center is 52% of container size, uses `pointer-events: none` with nested buttons having `pointer-events: auto`
- Tap detection uses angle-based calculation (not `document.elementFromPoint`) to work reliably after dial rotation
- Center exclusion zone (`dist < rect.width * 0.27`) prevents drag initiation when tapping S/Z or L1/L2 buttons
- Synthetic mouse events after touch are ignored for 500ms to prevent duplicate inputs

**CSS Structure:**
```css
.timer-view.radial-mode.active { /* Grid layout for radial view */ }
.dial-container { width: 100vw; height: 100vw; }
.dial-center { width: 52%; height: 52%; /* Contains time display, S/Z, L1/L2 */ }
.dial-number { /* Positioned absolutely around dial ring */ }
```

### Data Storage

- **LocalStorage keys**:
  - `skiTimerEntries` - Race timing entries
  - `skiTimerSettings` - User settings
  - `skiTimerAuthToken` - JWT authentication token
  - `skiTimerRaceId` - Current race ID
  - `skiTimerDeviceId` - Unique device identifier
  - `skiTimerRecentRaces` - Recently synced races (for quick-select)

- **Entry format**: `{ id, bib, point: 'S'|'F', run: 1|2, timestamp, status, deviceId, deviceName, photo? }`
- **Entry status values**: `ok` (normal), `dns` (did not start), `dnf` (did not finish), `dsq` (disqualified), `flt` (finished with fault penalty for U8/U10 categories)

### Feature Modules

Located in `src/features/`, these modules organize UI functionality by domain:

**View modules** (extracted from app.ts):
- **radialTimerView.ts** (~600 lines) - Radial dial timer interface, clock display, timestamp recording
- **timerView.ts** (~470 lines) - Classic timer view (hidden when radial mode active)
- **resultsView.ts** (~250 lines) - VirtualList, filtering, search, pull-to-refresh
- **settingsView.ts** (~550 lines) - Settings toggles, role selection, recent races
- **gateJudgeView.ts** (~350 lines) - Gate judge UI, gate assignment, ready status
- **chiefJudgeView.ts** (~630 lines) - Chief judge panel, fault summaries, deletion approvals
- **faultEntry.ts** (~950 lines) - Fault recording, editing, inline entry, deletion workflow
- **raceManagement.ts** (~950 lines) - PIN management, race CRUD, auth handling

**Utility modules**:
- **modals.ts** - Modal open/close utilities with animation support
- **ripple.ts** - Material Design ripple effect for touch feedback
- **export.ts** - CSV export in Race Horology format
- **photoViewer.ts** (~100 lines) - Photo viewing and deletion from IndexedDB

**CustomEvent pattern**: Modules communicate via CustomEvents for decoupled architecture:
```typescript
// In feature module: dispatch event
const event = new CustomEvent('fault-edit-request', {
  bubbles: true,
  detail: { fault }
});
element.dispatchEvent(event);

// In app.ts: listen for events
document.addEventListener('fault-edit-request', (e: CustomEvent) => {
  openFaultEditModal(e.detail.fault);
});
```

### Utility Modules

Located in `src/utils/`:
- **recentRaces.ts** - Track recently synced races for quick-select dropdown
- **errorBoundary.ts** - Global error handling and user-friendly error display
- **api.ts** - Centralized API client with auth headers
- **validation.ts** - Input validation for race IDs, entries, etc.
- **errors.ts** - Structured error logging
- **format.ts** - Time, date, and number formatting utilities

### Multi-Device Sync

Cross-device sync uses Redis (via ioredis) with polling:
- **API endpoint**: `/api/v1/sync` handles GET (fetch), POST (add), DELETE (remove)
- **Polling interval**: 5 seconds (30 seconds on error)
- **BroadcastChannel**: Used for same-browser tab sync
- **Race ID**: Case-insensitive unique identifier to group synced devices

### Authentication

JWT-based authentication protects sync and admin APIs:

1. **Token Exchange**: User enters 4-digit PIN ‚Üí `/api/v1/auth/token` returns JWT
2. **Token Storage**: JWT stored in localStorage (`skiTimerAuthToken`)
3. **Token Usage**: API calls include `Authorization: Bearer <token>` header
4. **Token Expiry**: 24-hour expiry, auto-prompts re-authentication
5. **Backwards Compatible**: Legacy PIN hash still accepted for migration

### Role-Based Access Control

JWT tokens include a `role` claim for authorization:

| Role | Description | Permissions |
|------|-------------|-------------|
| `timer` | Default role for timing devices | Read/write entries and faults |
| `gateJudge` | Gate judge devices | Read/write entries and faults |
| `chiefJudge` | Chief judge with elevated privileges | All above + **delete faults** |

- **Fault deletion** requires `chiefJudge` role (server-side enforced)
- Role is specified when exchanging PIN for token: `{ pin: "1234", role: "chiefJudge" }`
- Entering Chief Judge mode in the UI triggers re-authentication with `chiefJudge` role

### CSV Export Format (Race Horology)

Exports use semicolon delimiter and standard timing designators:
- **Columns**: Startnummer, Lauf, Messpunkt, Zeit, Status, Ger√§t
- **Timing Points**: ST (Start), FT (Finish)
- **Run (Lauf)**: 1 or 2 for multi-run races
- **Time Format**: HH:MM:SS.ss (hundredths of seconds)
- **CSV Injection Protection**: Formula characters escaped with single quote prefix

## Environment Variables

| Variable | Required | Description |
|----------|----------|-------------|
| `REDIS_URL` | Yes | Redis connection URL (Vercel KV or external Redis) |
| `JWT_SECRET` | **Production** | Secret for signing JWT tokens. **Required in production** - will fail to start without it. |
| `CORS_ORIGIN` | No | Allowed CORS origin (defaults to production domain) |

## API Endpoints

All endpoints use the `/api/v1/` prefix. Legacy `/api/*` paths are rewritten to v1 for backwards compatibility.

### `/api/v1/auth/token` (POST)
Exchange PIN for JWT token with optional role.
- **Body**: `{ pin: "1234", role?: "timer" | "gateJudge" | "chiefJudge" }`
- **Response**: `{ success: true, token: "jwt...", role: "timer", isNewPin?: true }`
- **Default role**: `timer` if not specified

### `/api/v1/sync` (GET/POST/DELETE)
Cloud sync for race entries. Requires JWT token when PIN is set.
- **GET**: Fetch entries for race
- **POST**: Add/update entry
- **DELETE**: Remove entry

### `/api/v1/faults` (GET/POST/DELETE)
Fault entries for gate judges. Requires JWT token.
- **GET**: Fetch faults for race (any authenticated role)
- **POST**: Add/update fault entry (any authenticated role)
- **DELETE**: Remove fault entry (**requires `chiefJudge` role**, returns 403 otherwise)

### `/api/v1/admin/races` (GET/DELETE)
Race management. Requires JWT token.
- **GET**: List all races with metadata
- **DELETE**: Delete race and set tombstone for connected clients

### `/api/v1/admin/pin` (GET/POST)
PIN hash management. Requires JWT token.
- **GET**: Get current PIN hash status
- **POST**: Set PIN hash

### `/api/v1/admin/reset-pin` (POST)
Reset PIN (server-side authentication via request body).
- **Body**: `{ serverPin: "<server-pin>" }`
- **Response**: `{ success: true, message: "PIN has been reset..." }`

## Testing

```bash
# Unit tests (Vitest)
npm test

# E2E tests (Playwright)
npm run test:e2e

# E2E with browser visible
npm run test:e2e:headed

# All tests
npm run test:all
```

## Vercel Deployment

1. Connect repository to Vercel
2. Add Vercel KV (Storage ‚Üí Create Database ‚Üí KV)
3. Set `JWT_SECRET` environment variable in Vercel dashboard
4. Deploy - environment variables auto-configured

## Version Management

**Always bump the version number in `package.json` after completing features or fixes.**

Follow semantic versioning (MAJOR.MINOR.PATCH):
- **PATCH** (x.x.1): Bug fixes, small tweaks, typo corrections
- **MINOR** (x.1.0): New features, enhancements, non-breaking changes
- **MAJOR** (1.0.0): Breaking changes, major rewrites, significant API changes

Examples:
- Single bug fix ‚Üí bump patch (4.1.0 ‚Üí 4.1.1)
- New feature like "Gate Judge" ‚Üí bump minor (4.0.0 ‚Üí 4.1.0)
- Complete rewrite or breaking change ‚Üí bump major (4.1.0 ‚Üí 5.0.0)

Commit the version bump separately with a message like "Bump version to X.Y.Z" summarizing what changed.

## Key Implementation Details

- **Translations**: In `src/i18n/translations.ts`, toggled via language setting. Default: German
  - Use `data-i18n` attribute on HTML elements for automatic translation
  - Short keys like `startShort`/`finishShort` for compact UI (S/F in English, S/Z in German)
  - Translations interface uses `[key: string]: string` index signature for flexibility
  - `updateTranslations()` in `settingsView.ts` scans all `[data-i18n]` elements and applies translations
  - For dynamic content in TypeScript, use `t('key', lang)` where `lang = store.getState().currentLang`
  - Aria-labels in templates need translation: ``aria-label="${t('deleteLabel', lang)}"``
  - Add new keys to BOTH `en:` and `de:` sections in translations.ts
- **Onboarding**: First-run wizard in `src/onboarding.ts` guides users through setup
  - Skip button allows dismissing at any time while saving progress (device name, role)
  - Completed state stored in localStorage (`skiTimerOnboarding`)
- **GPS sync**: Uses Geolocation API for real GPS timestamps
- **Haptic feedback**: Uses Navigator.vibrate() API
- **Sound feedback**: Uses Web Audio API for beep sounds
- **Photo capture**: Optional photo on timestamp, synced if <500KB
- **Mobile optimization**: Safe area insets for notches, touch-optimized, portrait lock
- **Service Worker**: Auto-generated by VitePWA with content-based versioning (no manual version bumps)
- **Error Handling**: Global error boundary catches uncaught errors with user-friendly recovery UI
- **TypeScript**: Strict mode enabled for better type safety
- **Motion effects**: Settings exist but currently disabled to save battery (see `src/main.ts:3-4`). The motion service uses device accelerometer for reactive UI effects.
- **Environment-aware logging**: Use `src/utils/logger.ts` - strips debug logs in production, keeps errors/warnings

## Security Best Practices

### XSS Prevention
- **Always use `escapeHtml()`** from `src/utils/format.ts` when inserting dynamic content into `innerHTML`
- This includes: bib numbers, device names, race IDs, gate numbers, any user-controlled data
- For `data-*` attributes and other HTML attributes, use `escapeAttr()`: `data-bib="${escapeAttr(bib)}"`
- Prefer `textContent` over `innerHTML` when not rendering HTML markup

### Example patterns:
```typescript
// GOOD: escaped for HTML content
element.innerHTML = `<span>${escapeHtml(userInput)}</span>`;

// GOOD: escaped for HTML attributes (includes quote escaping)
element.innerHTML = `<div title="${escapeAttr(userInput)}">...</div>`;

// BAD: vulnerable to XSS
element.innerHTML = `<span>${userInput}</span>`;

// BAD: escapeHtml doesn't escape quotes for attributes
element.innerHTML = `<div title="${escapeHtml(userInput)}">...</div>`;
// Input: `" onmouseover="alert(1)` breaks out of attribute
```

### Security Headers
Configure in `vercel.json` for defense in depth:
```json
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        { "key": "X-Content-Type-Options", "value": "nosniff" },
        { "key": "X-Frame-Options", "value": "DENY" },
        { "key": "Referrer-Policy", "value": "strict-origin-when-cross-origin" }
      ]
    }
  ]
}
```

## Browser API Error Handling

### User Notification on Silent Failures
Browser APIs often fail silently. Critical features should notify users:

```typescript
// Example: Wake Lock failure notification
try {
  this.wakeLock = await navigator.wakeLock.request('screen');
} catch (err) {
  // API failed - notify user about the impact
  const lang = store.getState().currentLang;
  showToast(t('wakeLockFailed', lang), 'warning', 5000);
}
```

**APIs that need failure notifications:**
- **Wake Lock**: Screen may dim during timing
- **GPS**: Location unavailable, times may be less accurate
- **Camera**: Photo capture disabled
- **Microphone**: Voice commands unavailable

### Cleanup on Error Paths
When registering handlers before an async operation, clean up if it fails:

```typescript
// Register handler
this.visibilityHandler = () => { ... };
document.addEventListener('visibilitychange', this.visibilityHandler);

try {
  await someAsyncOperation();
} catch (error) {
  // Clean up handler registered before the error
  document.removeEventListener('visibilitychange', this.visibilityHandler);
  this.visibilityHandler = null;
  throw error;
}
```

## Memory Management

### Event Listener Cleanup
Components that add event listeners MUST remove them in `destroy()`:
```typescript
// In constructor/init:
this.container.addEventListener('mousedown', this.handleDragStart);
window.addEventListener('resize', this.handleResize);

// In destroy():
this.container.removeEventListener('mousedown', this.handleDragStart);
window.removeEventListener('resize', this.handleResize);
```

### Store Subscription Cleanup
Components subscribing to store updates MUST unsubscribe when destroyed:
```typescript
// Subscribe
this.unsubscribe = store.subscribe((state, keys) => { ... });

// In destroy():
if (this.unsubscribe) {
  this.unsubscribe();
  this.unsubscribe = null;
}
```

### DOM Removal Detection
For components that might be removed from DOM without explicit `destroy()` call, use MutationObserver:
```typescript
this.domRemovalObserver = new MutationObserver((mutations) => {
  for (const mutation of mutations) {
    for (const removedNode of mutation.removedNodes) {
      if (removedNode.contains?.(this.container)) {
        this.destroy();
        return;
      }
    }
  }
});
this.domRemovalObserver.observe(this.container.parentElement, { childList: true, subtree: true });
```

### Double-Destruction Guard
Always guard against `destroy()` being called multiple times:
```typescript
private isDestroyed = false;

destroy(): void {
  if (this.isDestroyed) return;
  this.isDestroyed = true;
  // ... cleanup code
}
```

## Accessibility

### ARIA Attributes for Interactive Elements
All interactive elements must be accessible to screen readers:

```html
<!-- Icon-only buttons need aria-label -->
<button class="clear-btn" aria-label="Clear bib number">C</button>

<!-- SVGs inside buttons need aria-hidden -->
<button class="time-btn" aria-label="Record timestamp">
  <svg aria-hidden="true" ...></svg>
</button>

<!-- Dropdowns need expanded state and popup type -->
<button class="dropdown-btn" aria-label="Recent races" aria-expanded="false" aria-haspopup="listbox">
  <svg aria-hidden="true" ...></svg>
</button>

<!-- Toggle buttons need aria-pressed -->
<button class="ready-toggle-btn" aria-pressed="false">Ready</button>
```

### Radio Group Pattern
For mutually exclusive selections (timing points, runs, roles), use radio group semantics:

```html
<!-- Container with radiogroup role -->
<div class="timing-point" role="radiogroup" aria-label="Timing point">
  <button class="point-btn" role="radio" aria-checked="false" data-point="S">S</button>
  <button class="point-btn active" role="radio" aria-checked="true" data-point="F">F</button>
</div>
```

```typescript
// Update aria-checked when selection changes
function updateSelection(): void {
  container.querySelectorAll('.point-btn').forEach(btn => {
    const isActive = btn.getAttribute('data-point') === state.selectedPoint;
    btn.classList.toggle('active', isActive);
    btn.setAttribute('aria-checked', String(isActive));
  });
}
```

### Updating Dynamic ARIA States
When dropdown/menu state changes, update `aria-expanded`:
```typescript
dropdownBtn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
```

### Keyboard Navigation

#### General Principles
- All clickable elements must be focusable (buttons are by default)
- Custom controls should support keyboard interaction (Space/Enter to activate)
- Focus should be trapped in modals when open
- Modals should dismiss with Escape key

#### Tab Navigation (WCAG 2.1 Compliant)
For tab-like controls, implement arrow key navigation:
```typescript
btn.addEventListener('keydown', (e: KeyboardEvent) => {
  const tabs = Array.from(container.querySelectorAll('.tab-btn')) as HTMLElement[];
  const currentIndex = tabs.indexOf(btn);
  let newIndex = currentIndex;

  switch (e.key) {
    case 'ArrowLeft':
    case 'ArrowUp':
      e.preventDefault();
      newIndex = currentIndex > 0 ? currentIndex - 1 : tabs.length - 1;
      break;
    case 'ArrowRight':
    case 'ArrowDown':
      e.preventDefault();
      newIndex = currentIndex < tabs.length - 1 ? currentIndex + 1 : 0;
      break;
    case 'Home':
      e.preventDefault();
      newIndex = 0;
      break;
    case 'End':
      e.preventDefault();
      newIndex = tabs.length - 1;
      break;
  }

  if (newIndex !== currentIndex) {
    tabs[newIndex].focus();
    tabs[newIndex].click(); // Activate tab on focus
  }
});
```

#### List Navigation
For navigable lists (results, dropdowns), implement arrow key navigation:
```typescript
item.addEventListener('keydown', (e: KeyboardEvent) => {
  switch (e.key) {
    case 'Enter':
    case ' ':
      e.preventDefault();
      selectItem(item);
      break;
    case 'ArrowDown':
      e.preventDefault();
      focusNextItem(item);
      break;
    case 'ArrowUp':
      e.preventDefault();
      focusPreviousItem(item);
      break;
    case 'Escape':
      e.preventDefault();
      closeDropdown();
      break;
  }
});
```

#### Keyboard Shortcuts
Provide keyboard shortcuts for common actions:
```typescript
// Fault type shortcuts: M/G=MG, T=STR, B/R=BR
const key = event.key.toUpperCase();
switch (key) {
  case 'M':
  case 'G':
    selectFaultType('MG');
    break;
  case 'T':
    selectFaultType('STR');
    break;
  case 'B':
  case 'R':
    selectFaultType('BR');
    break;
}

// Run selection: Alt+1, Alt+2
if (e.altKey && (e.key === '1' || e.key === '2')) {
  e.preventDefault();
  store.setSelectedRun(e.key === '1' ? 1 : 2);
}
```

### Custom Interactive Elements
For non-button elements that respond to click, add full keyboard support:
```typescript
el.setAttribute('tabindex', '0');
el.setAttribute('role', 'button');
el.setAttribute('aria-label', 'Description of action');
el.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' || e.key === ' ') {
    e.preventDefault();
    handleClick();
  }
});
```

### Focus Indicators
All interactive elements need visible focus indicators:
```css
/* Add to focus-visible selector list in main.css */
.my-interactive-element:focus-visible {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}
```

### Focus Management
After showing overlays or modals, focus the first interactive element:
```typescript
document.body.appendChild(overlay);
setTimeout(() => {
  document.getElementById('dismiss-btn')?.focus();
}, 100);
```

## State Management Notes

### Notification Queue Race Conditions
The store uses a notification queue to handle re-entrant state changes. Key rules:
- Each notification captures its state snapshot at the time of the change
- Don't merge state snapshots when coalescing - only merge the changed key arrays
- The queue has a safety limit (`MAX_NOTIFICATION_QUEUE`) that drains oldest notifications when exceeded

## Key Learnings (Code Review Findings)

These patterns emerged from comprehensive code review and should be followed in all new code:

1. **Always escape user data before innerHTML** - Even seemingly "safe" data like bib numbers (`"045"`) should be escaped. Attackers can inject malicious race IDs or device names that flow through the system.

2. **Components need FULL event listener cleanup** - When a component adds listeners to both its container AND window/document, the `destroy()` method must remove ALL of them. Missing container listeners is a common oversight.

3. **Guard against double-destruction** - Always add an `isDestroyed` flag and check it at the start of `destroy()`. MutationObservers, error handlers, or user actions can trigger multiple destroy calls.

4. **Use MutationObserver for auto-cleanup** - When components might be removed from DOM without explicit `destroy()` (e.g., parent element removed), watch for removal and auto-cleanup to prevent memory leaks.

5. **Capture state snapshots immediately** - In notification/event systems, capture the state at the moment of change, not when processing the queue. Delayed snapshot capture causes race conditions where listeners see inconsistent state.

6. **Fail closed for security features** - Rate limiting, authentication, and other security features should deny access when the backing service (Redis, etc.) fails, not allow access.

7. **Escape data attributes too** - `data-*` attributes are often forgotten but can be vectors for attribute injection attacks.

8. **Notify users when browser APIs fail silently** - APIs like Wake Lock can fail without visible feedback (low battery, permission denied, page not visible). Always notify users when critical features fail, e.g., "Screen may dim during timing" toast when wake lock fails.

9. **Clean up event handlers on ALL error paths** - When registering event listeners before an async operation, ensure cleanup happens if the operation fails. Example: GPS visibility handler must be cleaned up if `watchPosition` throws.

10. **Accessible interactive elements need ARIA attributes** - Buttons with icons need `aria-label`, SVGs inside buttons need `aria-hidden="true"`, dropdowns need `aria-expanded` and `aria-haspopup`. Screen readers rely on these for navigation.

11. **Use escapeAttr() for HTML attributes** - `escapeHtml()` doesn't escape quotes. For attributes, use `escapeAttr()` which also escapes `"` and `'`. A malicious input like `" onmouseover="alert(1)` can escape an unprotected attribute.

12. **Track separate RAF IDs for different animations** - When a component has multiple animation types (e.g., momentum spin vs snap-back), use separate RAF ID variables. Otherwise one animation can cancel another incorrectly, or animations run forever when interrupted.

13. **Check RAF ID before scheduling recovery** - When error recovery schedules a new RAF, first check if `animationId === null`. Scheduling without checking can create duplicate concurrent loops (120fps instead of 60fps), doubling battery drain.

14. **Clear debounce timers when state changes directly** - Functions like `applyFilters()` that call `render()` directly should clear any pending debounced `render()` calls to prevent double execution.

15. **Show loading states during async operations** - Users need feedback. Show loading indicator (spinner, text) before async operations, then update with results/errors after completion.

16. **Warn users about deferred validation** - When validation is skipped (e.g., offline PIN check), warn users it will happen later: "PIN will be verified when online". Prevents surprise failures.

17. **Modals should dismiss with Escape key** - Standard UX pattern users expect. Add `keydown` listener for Escape that calls dismiss/close handler.

18. **Use semantic HTML for data display** - Definition lists (`<dl>`, `<dt>`, `<dd>`) convey label-value relationships to screen readers better than generic divs with spans.

19. **Focus management after showing overlays** - After displaying error overlays or modals, focus the first interactive element (usually dismiss/close button) so keyboard users can proceed.

20. **Add visual feedback for actions** - Buttons should provide visual confirmation (CSS flash/pulse animation) in addition to haptic feedback, especially for actions like "Clear" where the result might not be immediately visible.

21. **Add keyboard support to custom interactive elements** - Elements that respond to click need: `tabindex="0"`, `role="button"`, `aria-label`, and `keydown` handler for Enter/Space.

22. **Security headers provide defense in depth** - Add `X-Content-Type-Options: nosniff`, `X-Frame-Options: DENY`, and `Referrer-Policy` headers in vercel.json. These protect even if code-level defenses fail.

23. **Use role="radiogroup" for mutually exclusive choices** - When buttons form a group where only one can be active (timing points, runs, roles), wrap in a container with `role="radiogroup"` and `aria-label`. Each option gets `role="radio"` and `aria-checked`.

24. **Update aria-checked on selection change** - When selection state changes via JavaScript, always update `aria-checked` alongside the visual class toggle. Screen readers rely on this attribute.

25. **Button elements get Enter/Space for free** - Native `<button>` elements automatically respond to Enter and Space keys. Only add explicit keyboard handlers for additional shortcuts (like arrow keys) or for non-button elements.

26. **WCAG tab navigation uses arrow keys** - Tab lists should use arrow keys (not Tab) to move between tabs. Tab key moves to the next component. Implement Home/End for first/last tab.

27. **Decorative icons need aria-hidden** - Emoji icons inside buttons (‚è±Ô∏è, üö©) should have `aria-hidden="true"` to prevent screen readers from announcing them.

28. **Use CustomEvents instead of callbacks** - For cross-module communication, dispatch CustomEvents with `bubbles: true` instead of callback injection. This prevents circular dependencies and allows multiple listeners.

29. **Focus-visible over focus for keyboard users** - Use `:focus-visible` CSS pseudo-class instead of `:focus` to show focus rings only for keyboard navigation, not mouse clicks.

30. **List items need tabindex for keyboard nav** - Dynamically created list items (results, dropdown options) need `tabindex="0"` to be focusable. Add arrow key handlers for navigation between items.

31. **All user-visible text must use translations** - Hardcoded strings like "Pull to refresh", "Ready", "Synced" must use `t()` function or `data-i18n` attributes. Check modals, tooltips, aria-labels, and dynamically generated content.

32. **Aria-labels need localization too** - Screen reader labels like `aria-label="Delete"` or `aria-label="Gate 5"` must be translated. Use template literals with `t()`: ``aria-label="${t('gateNumberLabel', lang)} ${gate}"``.

33. **Modal content needs data-i18n attributes** - Content inside modals defined in index.html needs `data-i18n` attributes since `updateTranslations()` scans the entire document. Static HTML defaults to English; JavaScript applies translations on load and language change.

34. **Check all text sources when localizing** - Hardcoded text appears in: innerHTML templates, textContent assignments, aria-label attributes, title/tooltip attributes, placeholder attributes, and status indicators. All must use translation keys.

35. **Import store and t() in components that display text** - Components like `PullToRefresh` or `RadialDial` that render user-visible text need to import both `store` (for `currentLang`) and `t()` from translations, even if they didn't originally need localization.

36. **Remove deprecated auth methods, don't just mark deprecated** - Legacy authentication paths (like accepting PIN hash directly) create security vulnerabilities. If someone obtains the hash, they can authenticate without knowing the PIN. Remove legacy code entirely rather than leaving it with warnings.

37. **Sensitive data in request body, not headers** - Headers can be logged by proxies, CDNs, and load balancers. Server PINs, API keys, and other secrets should be sent in the request body (over HTTPS) rather than headers like `X-Server-Pin`.

38. **Track listeners in Maps for per-item cleanup** - For components that create multiple items with listeners (like VirtualList), use a `Map<itemId, { click, keydown, ... }>` to track listeners per item. This enables proper cleanup when items are removed or re-rendered.

39. **Modal functions must clean up previous listeners** - Functions like `openFaultModal()` that add event listeners must remove old listeners before adding new ones. Store listener references at module level and remove them at the start of the function.

40. **Wrap async init chains in try-catch** - Functions like `pushLocalEntries()` called during initialization should be wrapped in try-catch. One failure shouldn't prevent other initialization steps from completing.

41. **BroadcastChannel handlers need defensive parsing** - Message handlers should use `event.data || {}` and wrap processing in try-catch. Malformed messages from other tabs shouldn't crash the listener.

42. **Promise chains need .catch() even for fire-and-forget** - Even if you don't need the result, add `.catch()` to log errors. Silent promise rejections hide bugs: `initializeAdminPin().then(...).catch(err => logger.error(err))`.

43. **Track visual effect timeouts, clear in destroy()** - Store setTimeout IDs in a Set and clear all in `destroy()`. Prevents callbacks firing after component destruction causing errors or visual glitches.

44. **Use existing data structures over DOM queries** - Instead of `querySelectorAll('[tabindex="0"]')` on every keystroke, use the component's existing Map of visible items. DOM queries are expensive; data structure lookups are O(1).

45. **Queue bounds check before push, not conditionally** - If a notification queue has a max size, check and drain BEFORE every push, not just inside an `if (isProcessing)` block. Ensures bounds are respected regardless of processing state.

46. **Dispatch events for error states** - When sync operations fail, dispatch CustomEvents like `fault-sync-error` so UI components can update status indicators. Don't just log errors silently.

47. **API helpers should return result objects** - Functions like `updateHighestBib()` should return `{ success: true }` or `{ success: false, error: '...' }` rather than returning void or throwing. Callers can then include warnings in responses.

48. **Form labels need explicit `for` attribute** - Labels should have `for="input-id"` pointing to the input's `id`. Implicit association (label wrapping input) works but explicit is clearer. Toggle switches with wrapped checkboxes are an exception.

49. **Dynamic containers need aria-live** - Containers that are populated dynamically (empty states, lists that load async) need `aria-live="polite"` so screen readers announce when content appears.

50. **Test offline transitions thoroughly** - PWA offline testing should verify: (1) recording works offline, (2) data persists in localStorage, (3) app works after going back online, (4) no errors in console during transitions. Use Playwright's `context.setOffline(true/false)`.

51. **Style elements created dynamically must be cleaned up** - If a component appends a `<style>` element to `document.head` (for animations, etc.), store the reference and remove it in `destroy()`. Otherwise styles accumulate on component re-creation.

52. **Validate function parameters defensively** - Functions that receive IDs (like `deleteRace(raceId)`) should validate the parameter exists and is the right type before calling methods on it. `raceId.toLowerCase()` throws if raceId is null.

53. **Array access needs bounds validation** - Before accessing `config.intervals[index]`, verify `config.intervals` exists and has elements. Add fallbacks: `config.intervals?.[index] ?? config.baseInterval`.

## Animation Patterns

### Multiple Animation Types
When a component has different animation modes (e.g., momentum vs snap-back), track them separately:
```typescript
private spinAnimationId: number | null = null;
private snapBackAnimationId: number | null = null;

// When starting new interaction, cancel BOTH
if (this.spinAnimationId) cancelAnimationFrame(this.spinAnimationId);
if (this.snapBackAnimationId) cancelAnimationFrame(this.snapBackAnimationId);
```

### RAF Error Recovery
When recovering from errors in RAF loops, prevent duplicate loops:
```typescript
} catch (error) {
  logger.error('Tick error:', error);
  // Only schedule recovery if not already scheduled
  if (this.animationId === null) {
    this.animationId = requestAnimationFrame(this.tick);
  }
}
```

### Debounce + Direct Call Interaction
When a debounced function can also be called directly, clear pending debounce:
```typescript
applyFilters(): void {
  // Clear any pending debounced render
  if (this.scrollDebounceTimeout !== null) {
    clearTimeout(this.scrollDebounceTimeout);
    this.scrollDebounceTimeout = null;
  }
  // ... then render directly
  this.render();
}
```

## Radial Dial Development Notes

When working on the radial dial component, be aware of these common issues:

### Touch Event Handling
- **Synthetic mouse events**: After a touch event, browsers fire synthetic mouse events. Track `lastTouchTime` and ignore mouse events within 500ms of touch.
- **Pointer events**: The dial center has `pointer-events: none` to allow touch-through, but nested buttons (S/Z, L1/L2) need `pointer-events: auto`.
- **Event binding**: Events must be bound to the container (not gesture area) to catch interactions with number buttons.

### Tap Detection
- **Don't use `document.elementFromPoint`**: After dial rotation, the visual position of elements changes but `elementFromPoint` may not find them reliably.
- **Use angle-based detection**: Calculate the tap angle relative to dial center, subtract current rotation, then find the closest number within tolerance (20¬∞ = half of 36¬∞ spacing).

### State Management
- **Snap-back cleanup**: When snap-back animation completes, clear `spinAnimationId`, `isSpinning`, and remove `momentum` class.
- **Animation cancellation**: When starting a new drag/tap during animation, cancel the animation and reset `isSpinning`.

### Layout Considerations
- **Dial size**: Currently 100vw to fill screen width. Dial center at 52% leaves room for numbers at 38% radius.
- **Overlap prevention**: Use negative margins on `.radial-center-area` and constrained height on record button to prevent overlap.
- **Z-index layers**: dial-ring (base), dial-numbers (z-index: 10), dial-center (z-index: 15), top-row (z-index: 20)

### Landscape Mode Layout

In landscape orientation, the radial dial uses a completely different two-column layout:

**Structure:**
- **Left column**: Dial only (full viewport height, no header/tab bar constraints)
- **Right column**: Header ‚Üí Bib input ‚Üí Stats ‚Üí Record button ‚Üí Tab bar

**CSS Implementation** (in `src/styles/radial-dial.css`):
```css
/* Grid at .app level with display:contents to flatten hierarchy */
.app:has(.timer-view.radial-mode.active) {
  display: grid;
  grid-template-columns: auto 1fr;
  grid-template-rows: auto auto auto 1fr auto;
  column-gap: 16px;
}

/* Dissolve containers so children participate in parent grid */
.app:has(...) > #main { display: contents; }
.timer-view.radial-mode.active { display: contents; }
.radial-bottom-row { display: contents; }

/* Dial spans all rows in left column */
.radial-center-area { grid-column: 1; grid-row: 1 / -1; }

/* Right column elements placed in specific rows */
.header { grid-column: 2; grid-row: 1; }
.radial-top-row { grid-column: 2; grid-row: 2; }
.radial-stats-corner { grid-column: 2; grid-row: 3; }
.radial-time-btn-corner { grid-column: 2; grid-row: 4; }
.tab-bar { grid-column: 2; grid-row: 5; }
```

**Key techniques:**
- `display: contents` flattens DOM hierarchy allowing nested elements to participate in ancestor grid
- Dial size uses `min(100vh - 8px, 100dvh - 8px, 55vw)` to fit viewport height
- Header and tab bar only span right column, giving dial maximum vertical space
- Resize handler in `RadialDial.ts` regenerates number positions on orientation change

**Responsive breakpoints:**
- `@media (orientation: landscape)` - Base landscape layout
- `@media (orientation: landscape) and (max-height: 450px)` - Compact layout for short phones

## Keyboard Shortcuts Reference

The app supports full keyboard/USB numpad navigation:

### Timer View (Radial Dial)
| Key | Action |
|-----|--------|
| `0-9` | Enter bib number digit |
| `S` | Select Start timing point |
| `F` | Select Finish timing point |
| `Alt+1` | Select Run 1 |
| `Alt+2` | Select Run 2 |
| `Space` / `Enter` | Record timestamp |
| `Escape` / `Delete` | Clear bib input |
| `Backspace` | Delete last digit |

### Gate Judge (Fault Entry)
| Key | Action |
|-----|--------|
| `M` or `G` | Select Missed Gate (MG) |
| `T` | Select Straddled (STR) |
| `B` or `R` | Select Broken (BR) |
| `1-9`, `0` | Select gate number (0 = gate 10) |
| `Arrow keys` | Navigate between buttons |
| `Space` / `Enter` | Confirm selection |

### Results View
| Key | Action |
|-----|--------|
| `Arrow Up/Down` | Navigate between items |
| `Enter` / `Space` / `E` | Edit selected item |
| `Delete` / `D` | Delete selected item |

### Global
| Key | Action |
|-----|--------|
| `Tab` | Move to next component |
| `Shift+Tab` | Move to previous component |
| `Escape` | Close modal/dropdown |
| `Arrow keys` | Navigate within component |
